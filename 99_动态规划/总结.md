## 感想
遇到dp[i - 2]时，应该单独自己去处理dp[1]的特殊情况。
组合问题可以用完全背包解决。

在dp中，dp[i] = true时，注意下一轮是否会覆盖掉，一般用dp[i] = dp[i] || dp[i - 1]

利用二维dp数组解决完全背包问题，可能带来O(n^2)问题。

子序列中:
回文子串个数中dp[i][j] = dp[i + 1][j -1]，遍历顺序要注意


单个中： 子串?子序列? 


求排列组合数量: 可以用动态规划

### 二维dp
二维dp初始化时，交汇处需要单独领出来，同时结果可可能出现在初始化过程中。

### 子序列问题
1. 特殊串(例如回文) dp[i][j]，表示从下标i到下标j的子串是否是回文串。
2. 递增串: dp[i], 表示以i结尾的串的长度。

### 爬楼梯（可以解决排列问题）

### 背包问题 （可以解决组合问题，不能解决排列问题）
dp[nums.size() + 1][capacity + 1]是为了更好初始化，例如题目：https://leetcode.cn/problems/target-sum/

我认为背包问题中，用一维dp解决二维dp最大的好处，在于完全背包中，从O(n^3)降低为O(n^2)


## 进一步深度理解，具体选哪一些呢


### 错题
1. 最大子序列和。
2. 打家劫舍树版
3. 回文子串
4. 不同的子序列，（初始化特别容易错）
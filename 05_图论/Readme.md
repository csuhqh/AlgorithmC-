## 图论
## 易错
1. bsf/dfs的参数引用&记得添加。
## BFS
记得每次在节点入栈时就visited。

### 图的存储结构: G(V, E)
邻接矩阵: 固定O(V);
```
int graph[v][v]; //图的邻接矩阵
```
邻接表: 每一个顶点集合只有一个边的指针，通过边指针找到第一条边，每一条边指向下一条边，取出边快，取入边O(E);
```
typedef struct Edge{
  int adj; //边连接的另一个顶点
  Edge* nextEdge; //
}

typedef struct Node{
  char info; //节点自身的信息
  Edge* firstEdge;
}

Node graph[V]; //定义一个图
```
邻接多重表: 添加指针，每个顶点节点不变，但是边节点有所改变。
### 图的遍历算法
类似于树的先序遍历。（需要递归）
### 图的广度优先遍历
类似于树的层次遍历（不需要递归，需要队列）
- 适合最短距离，最长距离问题。

## 刷题感想
节点的数量，如果用邻接表存，则 n = graph.size();
求联通分量的类型，通常只需要遍历一次。

## DP模版
```
1. 定义dp[i][j], 并说明dp[i][j]含义
2. 确定转移方程
3. 初始化：
  - 顺序: 根据dp[i] = dp[i + 1] / dp[i - 1] 确定遍历顺序。
  - 结果可能存在于初始化中，
  - 二维初始化要注意交汇处 ！！
4. 注意: dp[i] = max(dp[i], xx) 还是dp[i] = xxx
```
## 易错
1. 下标对应问题: 注意dp[i]表示长度为i时，元素应该去nums[i - 1]
2. 遍历顺序: dp[i][j] = dp[i + 1][j - 1]，可以先写外层顺序j，再写内层i.（回文子串）
3. 求排列数量，dp[i] 一般是 +=

## 感想
遇到dp[i - 2]时，应该单独自己去处理dp[1]的特殊情况。
组合问题可以用完全背包解决。

在dp中，dp[i] = true时，注意下一轮是否会覆盖掉，一般用dp[i] = dp[i] || dp[i - 1]

利用二维dp数组解决完全背包问题，可能带来O(n^2)问题。

子序列中:
回文子串个数中dp[i][j] = dp[i + 1][j -1]，遍历顺序要注意


单个中： 子串?子序列? 


求排列组合数量: 可以用动态规划

### 二维dp
二维dp初始化时，交汇处需要单独领出来，同时结果可可能出现在初始化过程中。


### 子序列问题
公共子序列：只可以删除的编辑距离。（可能加以限制某个字符串不能被删）
1. 特殊串(例如回文) dp[i][j]，表示从下标i到下标j的子串是否是回文串。
2. 递增串: dp[i], 表示以i结尾的串的长度。

### 爬楼梯（可以解决排列问题）

### 背包问题 （可以解决组合问题，不能解决排列问题）
dp[nums.size() + 1][capacity + 1]是为了更好初始化，例如题目：https://leetcode.cn/problems/target-sum/

我认为背包问题中，用一维dp解决二维dp最大的好处，在于完全背包中，从O(n^3)降低为O(n^2)


## 进一步深度理解，具体选哪一些呢


### 错题
1. 最大子序列和。
2. 打家劫舍树版
3. 回文子串
4. 不同的子序列，（初始化特别容易错）